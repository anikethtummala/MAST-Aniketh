{
  "run_id": 25,
  "prompt": "write a program to calculate the shortest path in a graph using Dijkstra's algorithm",
  "content": "2025-01-17 11:40:07.055 | INFO     | metagpt.roles.role:_act:391 - Alice(SimpleCoder): to do SimpleWriteCode(SimpleWriteCode)\n```python\ndef dijkstra(graph, start):\n    shortest_paths = {vertex: float('infinity') for vertex in graph}\n    shortest_paths[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices = graph.copy()\n    while vertices:\n        current_vertex = min(vertices, key=lambda vertex: shortest_paths[vertex])\n        for neighbour, cost in graph[current_vertex].items():\n            alternative_route = shortest_paths[current_vertex] + cost\n            if alternative_route < shortest_paths[neighbour]:\n                shortest_paths[neighbour] = alternative_route\n                previous_vertices[neighbour] = current_vertex\n        vertices.pop(current_vertex)\n    return shortest_paths, previous_vertices\n```\n2025-01-17 11:40:11.674 | INFO     | __main__:_act:85 - Bob(SimpleTester): to do SimpleWriteTest(SimpleWriteTest)\n```python\nimport pytest\ndef test_dijkstra_simple_case():\n    graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'C': 2, 'D': 5},\n        'C': {'A': 4, 'B': 2, 'D': 1},\n        'D': {'B': 5, 'C': 1}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': 'B', 'D': 'C'}\ndef test_dijkstra_single_vertex():\n    graph = {'A': {}}\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0}\n    assert previous_vertices == {'A': None}\ndef test_dijkstra_unreachable_vertex():\n    graph = {\n        'A': {'B': 2},\n        'B': {'A': 2},\n        'C': {}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 2, 'C': float('infinity')}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': None}\ndef test_dijkstra_complete_graph():\n    graph = {\n        'A': {'B': 1, 'C': 2},\n        'B': {'A': 1, 'C': 1},\n        'C': {'A': 2, 'B': 1}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 1, 'C': 2}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': 'A'}\ndef test_dijkstra_no_path():\n    graph = {\n        'A': {'B': 5},\n        'B': {'C': 5},\n        'C': {},\n        'D': {}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 5, 'C': 10, 'D': float('infinity')}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': 'B', 'D': None}\n```\n2025-01-17 11:40:24.263 | INFO     | metagpt.roles.role:_act:391 - Charlie(SimpleReviewer): to do SimpleWriteReview(SimpleWriteReview)\n2025-01-17 11:40:26.599 | INFO     | __main__:_act:85 - Bob(SimpleTester): to do SimpleWriteTest(SimpleWriteTest)\n```python\nimport pytest\ndef test_dijkstra_negative_edge_weight():\n    graph = {\n        'A': {'B': -1, 'C': 4},\n        'B': {'A': 1, 'C': 2, 'D': 5},\n        'C': {'A': 4, 'B': 2, 'D': 1},\n        'D': {'B': 5, 'C': 1}\n    }\n    with pytest.raises(ValueError):\n        dijkstra(graph, 'A')\ndef test_dijkstra_loop_in_graph():\n    graph = {\n        'A': {'B': 1},\n        'B': {'C': 2},\n        'C': {'A': 3}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 1, 'C': 3}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': 'B'}\ndef test_dijkstra_multiple_paths_same_cost():\n    graph = {\n        'A': {'B': 2, 'C': 2},\n        'B': {'D': 2},\n        'C': {'D': 2},\n        'D': {}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 2, 'C': 2, 'D': 4}\n    # This test does not assert previous_vertices because there are multiple valid solutions\ndef test_dijkstra_graph_with_isolated_vertex():\n    graph = {\n        'A': {'B': 3},\n        'B': {'A': 3, 'C': 4},\n        'C': {'B': 4},\n        'D': {}\n    }\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths == {'A': 0, 'B': 3, 'C': 7, 'D': float('infinity')}\n    assert previous_vertices == {'A': None, 'B': 'A', 'C': 'B', 'D': None}\ndef test_dijkstra_large_graph():\n    graph = {chr(i): {chr(i+1): 1 for i in range(65, 90)}}\n    graph.update({chr(i+1): {chr(i): 1 for i in range(65, 90)}})  # Add reverse path\n    shortest_paths, previous_vertices = dijkstra(graph, 'A')\n    assert shortest_paths['Z'] == 25\n    # This test does not assert previous_vertices because the focus is on the path length\n```\n2025-01-17 11:40:44.865 | INFO     | metagpt.roles.role:_act:391 - Charlie(SimpleReviewer): to do SimpleWriteReview(SimpleWriteReview)",
  "timestamp": "2025-01-17 11:40:07",
  "cost": 0.08,
  "log_file": "logs/25.txt"
}